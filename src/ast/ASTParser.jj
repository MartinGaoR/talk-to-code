/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(ASTParser)package ast;
import java.util.*;
public class ASTParser{  public static void main(String args []) throws ParseException  {    ASTParser parser = new ASTParser(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("Enter an expression like \"1+(2+3)*4;\" :");      try      {        parser.statement();
        System.out.println("OK");      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        ASTParser.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(ASTParser)
/**********************************************
 * THE JAVACC TOKEN SPECIFICATION STARTS HERE *
 **********************************************/

/* JAVACC RESERVED WORDS: These are the only tokens in JavaCC but not in Java */
<DEFAULT> TOKEN : {
<_LOOKAHEAD: "LOOKAHEAD">
| <_IGNORE_CASE: "IGNORE_CASE">
| <_PARSER_BEGIN: "PARSER_BEGIN">
| <_PARSER_END: "PARSER_END">
| <_JAVACODE: "JAVACODE">
| <_TOKEN: "TOKEN">
| <_SPECIAL_TOKEN: "SPECIAL_TOKEN">
| <_MORE: "MORE">
| <_SKIP: "SKIP">
| <_TOKEN_MGR_DECLS: "TOKEN_MGR_DECLS">
| <_EOF: "EOF">
}

   
/*
 * The remainder of the tokens are exactly (except for the removal of tokens
 * containing ">>" and "<<") as in the Java grammar and must be diff equivalent
 * (again with the exceptions above) to it.
 */

/* WHITE SPACE */
<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| "\f"
| "/*@egen*/" : AFTER_EGEN
}

   
<AFTER_EGEN> SKIP : {
<~[]> : DEFAULT
}

   

   
/* JAVA RESERVED WORDS AND LITERALS */
<DEFAULT> TOKEN : {
<ABSTRACT: "abstract">
| <ASSERT: "assert">
| <BOOLEAN: "boolean">
| <BREAK: "break">
| <BYTE: "byte">
| <CASE: "case">
| <CATCH: "catch">
| <CHAR: "char">
| <CLASS: "class">
| <CONST: "const">
| <CONTINUE: "continue">
| <_DEFAULT: "default">
| <DO: "do">
| <DOUBLE: "double">
| <ELSE: "else">
| <ENUM: "enum">
| <EXTENDS: "extends">
| <FALSE: "false">
| <FINAL: "final">
| <FINALLY: "finally">
| <FLOAT: "float">
| <FOR: "for">
| <GOTO: "goto">
| <IF: "if">
| <IMPLEMENTS: "implements">
| <IMPORT: "import">
| <INSTANCEOF: "instanceof">
| <INT: "int">
| <INTERFACE: "interface">
| <LONG: "long">
| <NATIVE: "native">
| <NEW: "new">
| <NULL: "null">
| <PACKAGE: "package">
| <PRIVATE: "private">
| <PROTECTED: "protected">
| <PUBLIC: "public">
| <RETURN: "return">
| <SHORT: "short">
| <STATIC: "static">
| <STRICTFP: "strictfp">
| <SUPER: "super">
| <SWITCH: "switch">
| <SYNCHRONIZED: "synchronized">
| <THIS: "this">
| <THROW: "throw">
| <THROWS: "throws">
| <TRANSIENT: "transient">
| <TRUE: "true">
| <TRY: "try">
| <VOID: "void">
| <VOLATILE: "volatile">
| <WHILE: "while">
}

   
/* JAVA LITERALS */
<DEFAULT> TOKEN : {
<INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
| <#OCTAL_LITERAL: "0" (["0"-"7"])*>
| <FLOATING_POINT_LITERAL: <DECIMAL_FLOATING_POINT_LITERAL> | <HEXADECIMAL_FLOATING_POINT_LITERAL>>
| <#DECIMAL_FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]>
| <#DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
| <#HEXADECIMAL_FLOATING_POINT_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])? | "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?>
| <#HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+>
| <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
| <STRING_LITERAL: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">
}

   
/* SEPARATORS */
<DEFAULT> TOKEN : {
<LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <SEMICOLON: ";">
| <COMMA: ",">
| <DOT: ".">
}

   
/* OPERATORS */
<DEFAULT> TOKEN : {
<ASSIGN: "=">
| <LT: "<">
| <BANG: "!">
| <TILDE: "~">
| <HOOK: "?">
| <COLON: ":">
| <EQ: "==">
| <LE: "<=">
| <GE: ">=">
| <NE: "!=">
| <SC_OR: "||">
| <SC_AND: "&&">
| <INCR: "++">
| <DECR: "--">
| <PLUS: "+">
| <MINUS: "-">
| <STAR: "*">
| <SLASH: "/">
| <BIT_AND: "&">
| <BIT_OR: "|">
| <XOR: "^">
| <REM: "%">
| <PLUSASSIGN: "+=">
| <MINUSASSIGN: "-=">
| <STARASSIGN: "*=">
| <SLASHASSIGN: "/=">
| <ANDASSIGN: "&=">
| <ORASSIGN: "|=">
| <XORASSIGN: "^=">
| <REMASSIGN: "%=">
}

TOKEN:{
    <INFIX_OPERATOR: < TEXT_ADD >|< TEXT_MINUS >|< TEXT_MULTIPLY >|< TEXT_DIVISION >|
    				 < TEXT_LESS_THAN >|< TEXT_GREATER_THAN >|< TEXT_EQUAL >|
    				 < TEXT_LESS_EQUAL >|< TEXT_GREATER_EQUAL >|< TEXT_NOT_EQUAL >|
    				 < TEXT_OR >|< TEXT_AND >|< TEXT_BIT_AND >|< TEXT_BIT_OR >|
    				 < TEXT_XOR >|< TEXT_MOD >|
    				 < TEXT_SHIFT_LEFT >|< TEXT_SHIFT_RIGHT >|< TEXT_SHIFT_RIGHT_ZERO > >| 	< TEXT_ADD: "#plus" >
| 	< TEXT_MINUS:"#minus" >
| 	< TEXT_MULTIPLY:"#multiply" >
| 	< TEXT_DIVISION:"#divide" >
| 	< TEXT_LESS_THAN:"#less_than" >
| 	< TEXT_GREATER_THAN:"#greater_than" >
| 	< TEXT_EQUAL: "#equal" >
|  	< TEXT_LESS_EQUAL: "#less_equal" >
|   < TEXT_GREATER_EQUAL:"#greater_equal" >
| 	< TEXT_NOT_EQUAL:"#not_equal" >
| 	< TEXT_OR: "#or" >
| 	< TEXT_AND: "#and" >
| 	< TEXT_BIT_AND: "#bit_and" >
| 	< TEXT_BIT_OR: "#bit_or" >
| 	< TEXT_XOR:"#bit_xor" >
| 	< TEXT_MOD:"#mod" >
| 	< TEXT_SHIFT_LEFT : "#shift_left" >
| 	< TEXT_SHIFT_RIGHT : "#shift_right" >
| 	< TEXT_SHIFT_RIGHT_ZERO : "#shift_right_zero" >
}
TOKEN:{
  < COMPOUND_OPERATOR: < TEXT_PLUS_EQUAL >|< TEXT_MINUS_EQUAL >|
    				 < TEXT_TIMES_EQUAL >|< TEXT_DIVIDE_EQUAL >|< TEXT_MOD_EQUAL >|
    				 < TEXT_OR_EQUAL >|< TEXT_AND_EQUAL >|< TEXT_XOR_EQUAL >>
| 	< TEXT_PLUS_EQUAL :"#plus_equal" >
|   < TEXT_MINUS_EQUAL :"#minus_equal" >
| 	< TEXT_TIMES_EQUAL :"#multiply_equal" >
| 	< TEXT_DIVIDE_EQUAL :"#divide_equal" >
| 	< TEXT_MOD_EQUAL : "#mod_equal" >
| 	< TEXT_AND_EQUAL : "#and_equal" >
| 	< TEXT_OR_EQUAL : "#or_equal" >
| 	< TEXT_XOR_EQUAL : "#xor_equal" > }
TOKEN:
{
  < PREFIX_OPERATOR: < TEXT_PRE_INC >|< TEXT_PRE_DEC >|< TEXT_NOT >>
| < TEXT_PRE_INC: "#pre_inc" >
| < TEXT_PRE_DEC: "#pre_dec" >
| < TEXT_NOT:"#not" >}
TOKEN:
{
   < TEXT_BIT_NOT:"#bit_not" >}
TOKEN:
{
    < POSTFIX_OPERATOR:<TEXT_POST_INC >|< TEXT_POST_DEC > > | 	< TEXT_POST_INC: "#post_inc" >
|   < TEXT_POST_DEC: "#post_dec" >
}
TOKEN:{
  < CONDITIONAL_OPERATOR:< TEXT_IF_YES >|< TEXT_IF_NOT > > 
| < TEXT_IF_YES: "#if_yes" >
| < TEXT_IF_NOT: "#if_not" >}

/* keywords */
TOKEN:
{
  < ASSIGNMENT : "#assign" >
| < CREATE : "#create" >
| < TYPE : "#type" >
| < VARIABLE: "#variable" >
| < VALUE: "#value" >
| < FUNCTION:"#function" >
| < WITH:"#with" >
| < CONDITION:"#condition" >
| < EXPRESSIONS: "#expression" >
| < IF_BRANCH_START:"#if_branch_start" >
| < IF_BRANCH_END:"#if_branch_end" >
| < ELSE_BRANCH_START:"#else_branch_start" >
| < ELSE_BRANCH_END:"#else_branch_end" >
| < PRE: "#pre" >
| < POST:"#post" >
| < TERMINATOR:";;" >
}

   
/* IDENTIFIERS */
TOKEN : {
<IDENTIFIER: <LETTER> (<PART_LETTER>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#PART_LETTER: ["$","0"-"9","A"-"Z","_","a"-"z"]>
}




ASTExpressionUnitValue value():
{
  Token n;
  Token sign;
  ASTExpressionUnitValue valueNode;
}
{
  n = < INTEGER_LITERAL >  {
    valueNode = new ASTExpressionUnitValue(n.image);
    //System.out.println(valueNode.print());
    return valueNode;
     }  | n = < FLOATING_POINT_LITERAL >{
    valueNode = new ASTExpressionUnitValue(n.image);
    //System.out.println(valueNode.print());
    return valueNode;
  }
  | n= < CHARACTER_LITERAL >{
    valueNode = new ASTExpressionUnitValue(n.image);
    //System.out.println(valueNode.print());
    return valueNode;
  }
  | n = < STRING_LITERAL >{
    valueNode = new ASTExpressionUnitValue(n.image);
    //System.out.println(valueNode.print());
    return valueNode;
  }
  | n = < TRUE >  {	 valueNode = new ASTExpressionUnitValue(n.image);
	 return valueNode;
  }
  |  n = < FALSE >
  {
    valueNode = new ASTExpressionUnitValue(n.image);
	 return valueNode;  }

}

String primitive_types():{Token n;}{	(
		  n = < BYTE >		{
		  //System.out.println(n.image);
		  return n.image;		}
		|n=< INT >
		{
		  //System.out.println(n.image);
		  return n.image;		}
		|n = < CHAR >
		{
		  //System.out.println(n.image);
		  return n.image;
		}
		|n=< DOUBLE >
		{
		  //System.out.println(n.image);
		  return n.image;
		}
		|n = < FLOAT >
		{
		  //System.out.println(n.image);
		  return n.image;
		}
		|n = < LONG >
		{
		  //System.out.println(n.image);
		  return n.image;
		}
		|n = < SHORT >
		{
		  //System.out.println(n.image);
		  return n.image;
		}
		|n = < BOOLEAN >
		{
		  return n.image;		} 
	)
	
}

String types():
{
  String type;
  Token n;
}{
  n =  < IDENTIFIER >  {    return n.image;  }  |type = primitive_types()  {
    return type;  }}
ASTNode create_variable():{
  String type;
  Token id;
  ASTExpressionAssignment result;
  ASTExpressionUnitIdentifier var;
  ASTExpression exp = new ASTExpression();}
{
  < CREATE >type = types()<VARIABLE >id=< IDENTIFIER >(exp = expression())< TERMINATOR >	{
	  var = new ASTExpressionUnitIdentifier(id.image,type,true);
	  result = new ASTExpressionAssignment();
	 	  result = new ASTExpressionAssignment(var,exp);

	  //System.out.println(result.print());
	  return result;	}
}
ASTExpression fragment():
{
  Token var = new Token();
  Token check = new Token();
  ASTExpressionUnitValue v = new ASTExpressionUnitValue();
  ASTExpression result = new ASTExpression();
}
{
  (< VALUE >v = value()){
     return v;
  }|(< VARIABLE >var = < IDENTIFIER >){
     return new ASTExpressionUnitIdentifier(var.image);
  }|(< FUNCTION >){
     return v;
  }|(check = < LPAREN > result = expression()< RPAREN >){
     result.setQuote();
     return result;
  }
  }

ASTExpression term():
{
  ArrayList<Token > operators = new ArrayList<Token >();
  ArrayList<ASTExpression > operands = new ArrayList<ASTExpression >();
  Token operator = new Token();
  ASTExpression operand1;
  ASTExpression operand2 = new ASTExpression();
  ASTExpression result;
}
{	operand1 = fragment()(operator = < INFIX_OPERATOR >	{operators.add(operator);} operand2 = fragment()	{operands.add(operand2);})*
	{
	  
	  	if(operator.image == null||operators.isEmpty())	  	{
	  	  result = operand1;
	  	  return result;	  	}
	  	result = new ASTExpression();
	  	while(!operators.isEmpty())	  	{			result = new ASTExpressionInfixOperation(operators.remove(0).image,operand1,operands.remove(0));
			operand1 = result;
	  	}
		return result;
	}
}

ASTExpression infix_expression():{
  ASTExpression result;
}
{	result = term()	{		return result;
	}
}
ASTExpression prefix_expression():{
  Token operator1;
  Token operator2;
  Token var_name;
  ASTExpressionUnitValue v = new ASTExpressionUnitValue();
  ASTExpressionUnitIdentifier i = new ASTExpressionUnitIdentifier();
  ASTExpressionPrefixOperation result;
}
{	(operator1 = < TEXT_BIT_NOT ><VALUE > v = value())
	{
	  result = new ASTExpressionPrefixOperation(operator1.image,v);
	  return result;	}
	|(operator2 = < PREFIX_OPERATOR ><VARIABLE > var_name = <IDENTIFIER >)
	{
	  result = new ASTExpressionPrefixOperation();
	  	  i = new ASTExpressionUnitIdentifier(var_name.image);
	  result = new ASTExpressionPrefixOperation(operator2.image,i);

	  return result;	}
}

ASTExpression postfix_expression():{
  Token operator;
  Token var;
  
}
{
  < POST >(< VARIABLE >var = <IDENTIFIER >)operator = < POSTFIX_OPERATOR >  {
    ASTExpressionUnitIdentifier i = new ASTExpressionUnitIdentifier(var.image);
    ASTExpressionPostfixOperation result = new ASTExpressionPostfixOperation(operator.image,i);
    //System.out.println(result.typeof());	return result;
  }}

ASTExpression expression():
{
  ASTExpression result1 = new ASTExpression();
  ASTExpression result2 = new ASTExpression();
  ASTExpression result3 = new ASTExpression();
}
{
  (result1 = prefix_expression(){
    	//System.out.println("image"+result.print());
    	//System.out.println("Hi");
	  return result1;
	}
	|result2 = infix_expression(){
	  //System.out.println("image"+result2.print());
	  //System.out.println("result3 "+result3.typeof());
	  return result2;
	}
	|result3 = postfix_expression(){
	  //System.out.println("image"+result.print());
	  //System.out.println(result3.typeof());
	  return result3;
	})
	
}
ASTNode compoundStatement():{
  Token var;
  Token operator;
  ASTExpression exp;}
{
  < VARIABLE >var =  <IDENTIFIER >operator = < COMPOUND_OPERATOR >exp = expression()< TERMINATOR >
  {
    ASTExpressionUnitIdentifier variable = new ASTExpressionUnitIdentifier(var.image);
    ASTExpressionInfixOperation result = new ASTExpressionInfixOperation(operator.image,variable,exp);
    result.end();
    return result;  }}
ASTNode assignment():
{
  Token var;
  ASTExpression exp;}
{	< ASSIGNMENT ><VARIABLE >var = <IDENTIFIER ><WITH>exp = expression()< TERMINATOR >
	{
	  ASTExpressionUnitIdentifier variable = new ASTExpressionUnitIdentifier(var.image);
	  ASTExpressionAssignment result = new ASTExpressionAssignment(variable,exp);
	  //System.out.println(result.print());
	  return result;	}
}

ASTIfStatement if_statement():
{
  ASTExpression condition;
  ASTNode stat1;
  ASTNode stat2;
  ArrayList<ASTNode > ifStat = new ArrayList<ASTNode >();
  ArrayList<ASTNode > elseStat = new ArrayList<ASTNode >();}
{
  < IF > <CONDITION >condition = expression()< IF_BRANCH_START >(stat1 = statement()  {ifStat.add(stat1);})*<IF_BRANCH_END >(< ELSE_BRANCH_START >(stat2 =statement()  {elseStat.add(stat2);})*< ELSE_BRANCH_END >)?< TERMINATOR >
  {
    //System.out.println(condition.print());
 	ASTIfStatement result = new ASTIfStatement(condition,ifStat,elseStat);
	
 	//System.out.println(result.print());	
    return result;  }}
ASTNode statement():
{
  ASTNode result;}
{
  (     result = assignment()
     {
       //System.out.println(result.print());
       return result;     }
    |result = if_statement()
     {
       //System.out.println(result.print());
       return result;     }
    |result = create_variable()     {
        //System.out.println(result.print());		return result;
     }
    |result = compoundStatement()     {
        //System.out.println(result.print());		return result;
     }
    |result = prefix_expression()< TERMINATOR >     {
       //System.out.println(result.print());
       return result;     }
    |result = postfix_expression()< TERMINATOR >
     {
       //System.out.println(result.print());
       return result;     }
  )}
