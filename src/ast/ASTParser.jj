/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(ASTParser)package ast;

public class ASTParser{  public static void main(String args []) throws ParseException  {    ASTParser parser = new ASTParser(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("Enter an expression like \"1+(2+3)*4;\" :");      try      {        parser.create_variable();
        System.out.println("OK");      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        ASTParser.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(ASTParser)
/**********************************************
 * THE JAVACC TOKEN SPECIFICATION STARTS HERE *
 **********************************************/

/* JAVACC RESERVED WORDS: These are the only tokens in JavaCC but not in Java */
<DEFAULT> TOKEN : {
<_LOOKAHEAD: "LOOKAHEAD">
| <_IGNORE_CASE: "IGNORE_CASE">
| <_PARSER_BEGIN: "PARSER_BEGIN">
| <_PARSER_END: "PARSER_END">
| <_JAVACODE: "JAVACODE">
| <_TOKEN: "TOKEN">
| <_SPECIAL_TOKEN: "SPECIAL_TOKEN">
| <_MORE: "MORE">
| <_SKIP: "SKIP">
| <_TOKEN_MGR_DECLS: "TOKEN_MGR_DECLS">
| <_EOF: "EOF">
}

   
/*
 * The remainder of the tokens are exactly (except for the removal of tokens
 * containing ">>" and "<<") as in the Java grammar and must be diff equivalent
 * (again with the exceptions above) to it.
 */

/* WHITE SPACE */
<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| "\f"
| "/*@egen*/" : AFTER_EGEN
}

   
<AFTER_EGEN> SKIP : {
<~[]> : DEFAULT
}

   

   
/* JAVA RESERVED WORDS AND LITERALS */
<DEFAULT> TOKEN : {
<ABSTRACT: "abstract">
| <ASSERT: "assert">
| <BOOLEAN: "boolean">
| <BREAK: "break">
| <BYTE: "byte">
| <CASE: "case">
| <CATCH: "catch">
| <CHAR: "char">
| <CLASS: "class">
| <CONST: "const">
| <CONTINUE: "continue">
| <_DEFAULT: "default">
| <DO: "do">
| <DOUBLE: "double">
| <ELSE: "else">
| <ENUM: "enum">
| <EXTENDS: "extends">
| <FALSE: "false">
| <FINAL: "final">
| <FINALLY: "finally">
| <FLOAT: "float">
| <FOR: "for">
| <GOTO: "goto">
| <IF: "if">
| <IMPLEMENTS: "implements">
| <IMPORT: "import">
| <INSTANCEOF: "instanceof">
| <INT: "int">
| <INTERFACE: "interface">
| <LONG: "long">
| <NATIVE: "native">
| <NEW: "new">
| <NULL: "null">
| <PACKAGE: "package">
| <PRIVATE: "private">
| <PROTECTED: "protected">
| <PUBLIC: "public">
| <RETURN: "return">
| <SHORT: "short">
| <STATIC: "static">
| <STRICTFP: "strictfp">
| <SUPER: "super">
| <SWITCH: "switch">
| <SYNCHRONIZED: "synchronized">
| <THIS: "this">
| <THROW: "throw">
| <THROWS: "throws">
| <TRANSIENT: "transient">
| <TRUE: "true">
| <TRY: "try">
| <VOID: "void">
| <VOLATILE: "volatile">
| <WHILE: "while">
}

   
/* JAVA LITERALS */
<DEFAULT> TOKEN : {
<INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
| <#OCTAL_LITERAL: "0" (["0"-"7"])*>
| <FLOATING_POINT_LITERAL: <DECIMAL_FLOATING_POINT_LITERAL> | <HEXADECIMAL_FLOATING_POINT_LITERAL>>
| <#DECIMAL_FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]>
| <#DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
| <#HEXADECIMAL_FLOATING_POINT_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])? | "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?>
| <#HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+>
| <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
| <STRING_LITERAL: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">
}

   
/* SEPARATORS */
<DEFAULT> TOKEN : {
<LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <SEMICOLON: ";">
| <COMMA: ",">
| <DOT: ".">
}

   
/* OPERATORS */
<DEFAULT> TOKEN : {
<ASSIGN: "=">
| <LT: "<">
| <BANG: "!">
| <TILDE: "~">
| <HOOK: "?">
| <COLON: ":">
| <EQ: "==">
| <LE: "<=">
| <GE: ">=">
| <NE: "!=">
| <SC_OR: "||">
| <SC_AND: "&&">
| <INCR: "++">
| <DECR: "--">
| <PLUS: "+">
| <MINUS: "-">
| <STAR: "*">
| <SLASH: "/">
| <BIT_AND: "&">
| <BIT_OR: "|">
| <XOR: "^">
| <REM: "%">
| <PLUSASSIGN: "+=">
| <MINUSASSIGN: "-=">
| <STARASSIGN: "*=">
| <SLASHASSIGN: "/=">
| <ANDASSIGN: "&=">
| <ORASSIGN: "|=">
| <XORASSIGN: "^=">
| <REMASSIGN: "%=">
}

TOKEN:{
    <INFIX_OPERATOR: < TEXT_ADD >|< TEXT_MINUS >|< TEXT_MULTIPLY >|< TEXT_DIVISION >
    				 < TEXT_LESS_THAN >|< TEXT_GREATER_THAN >|< TEXT_EQUAL >|
    				 < TEXT_LESS_EQUAL >|< TEXT_GREATER_EQUAL >|< TEXT_NOT_EQUAL >|
    				 < TEXT_OR >|< TEXT_AND >|< TEXT_BIT_AND >|< TEXT_BIT_OR >|
    				 < TEXT_XOR >|< TEXT_MOD >|< TEXT_PLUS_EQUAL >|< TEXT_MINUS_EQUAL >|
    				 < TEXT_TIMES_EQUAL >|< TEXT_DIVIDE_EQUAL >|< TEXT_MOD_EQUAL >|
    				 < TEXT_OR_EQUAL >|< TEXT_AND_EQUAL >|< TEXT_XOR_EQUAL >|
    				 < TEXT_SHIFT_LEFT >|< TEXT_SHIFT_RIGHT >|< TEXT_SHIFT_RIGHT_ZERO > >| 	< TEXT_ADD: "#plus" >
| 	< TEXT_MINUS:"#minus" >
| 	< TEXT_MULTIPLY:"#multiply" >
| 	< TEXT_DIVISION:"#divide" >
| 	< TEXT_LESS_THAN:"#less_than" >
| 	< TEXT_GREATER_THAN:"#greater_than" >
| 	< TEXT_EQUAL: "#equal" >
|  	< TEXT_LESS_EQUAL: "#less_equal" >
|   < TEXT_GREATER_EQUAL:"#greater_equal" >
| 	< TEXT_NOT_EQUAL:"#not_equal" >
| 	< TEXT_OR: "#or" >
| 	< TEXT_AND: "#and" >
| 	< TEXT_BIT_AND: "#bit_and" >
| 	< TEXT_BIT_OR: "#bit_or" >
| 	< TEXT_XOR:"#bit_xor" >
| 	< TEXT_MOD:"#mod" >
| 	< TEXT_PLUS_EQUAL :"#plus_equal" >
|   < TEXT_MINUS_EQUAL :"#minus_equal" >
| 	< TEXT_TIMES_EQUAL :"#multiply_equal" >
| 	< TEXT_DIVIDE_EQUAL :"#divide_equal" >
| 	< TEXT_MOD_EQUAL : "#mod_equal" >
| 	< TEXT_AND_EQUAL : "#and_equal" >
| 	< TEXT_OR_EQUAL : "#or_equal" >
| 	< TEXT_XOR_EQUAL : "#xor_equal" >
| 	< TEXT_SHIFT_LEFT : "#shift_left" >
| 	< TEXT_SHIFT_RIGHT : "#shift_right" >
| 	< TEXT_SHIFT_RIGHT_ZERO : "#shift_right_zero" >
}TOKEN:
{
  < PREFIX_OPERATOR: < TEXT_PRE_INC >|< TEXT_PRE_DEC >|< TEXT_NOT >|< TEXT_BIT_NOT > >
| < TEXT_PRE_INC: "#pre_inc" >
| < TEXT_PRE_DEC: "#pre_dec" >
| < TEXT_NOT:"#not" >
| < TEXT_BIT_NOT:"#bit_not" >}

TOKEN:
{
    < POSTFIX_OPERATOR:<TEXT_POST_INC >|< TEXT_POST_DEC > > | 	< TEXT_POST_INC: "#post_inc" >
|   < TEXT_POST_DEC: "#post_dec" >
}
TOKEN:{
  < CONDITIONAL_OPERATOR:< TEXT_IF_YES >|< TEXT_IF_NOT > > 
| < TEXT_IF_YES: "#if_yes" >
| < TEXT_IF_NOT: "#if_not" >}

/* keywords */
TOKEN:
{
  < ASSIGNMENT : "#assign" >
| < CREATE : "#create" >
| < TYPE : "#type" >
| < VARIABLE: "#variable" >
| < VALUE: "#value" >
| < FUNCTION:"#function" >
| < WITH:"#with" >
| < CONDITION:"#condition" >
| < IF_BRANCH_START:"#if_branch_start" >
| < IF_BRANCH_END:"#if_branch_end" >
| < ELSE_BRANCH_START:"#else_branch_start" >
| < ELSE_BRANCH_END:"#else_branch_end" >
| < TERMINATOR:";;" >
}

   
/* IDENTIFIERS */
TOKEN : {
<IDENTIFIER: <LETTER> (<PART_LETTER>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#PART_LETTER: ["$","0"-"9","A"-"Z","_","a"-"z"]>
}




ASTExpressionUnitValue value():
{
  Token n;
  ASTExpressionUnitValue valueNode;
}
{
  n = < INTEGER_LITERAL >  {
    valueNode = new ASTExpressionUnitValue(n.image);
    System.out.println(valueNode.print());
    return valueNode;
     }  | n = < FLOATING_POINT_LITERAL >{
    valueNode = new ASTExpressionUnitValue(n.image);
    System.out.println(valueNode.print());
    return valueNode;
  }
  | n= < CHARACTER_LITERAL >{
    valueNode = new ASTExpressionUnitValue(n.image);
    System.out.println(valueNode.print());
    return valueNode;
  }
  | n = < STRING_LITERAL >{
    valueNode = new ASTExpressionUnitValue(n.image);
    System.out.println(valueNode.print());
    return valueNode;
  }
}

String primitive_types():{Token n;}{	(
		  n = < BYTE >		{
		  System.out.println(n.image);
		  return n.image;		}
		|n=< INT >
		{
		  System.out.println(n.image);
		  return n.image;		}
		|n = < CHAR >
		{
		  System.out.println(n.image);
		  return n.image;
		}
		|n=< DOUBLE >
		{
		  System.out.println(n.image);
		  return n.image;
		}
		|n = < FLOAT >
		{
		  System.out.println(n.image);
		  return n.image;
		}
		|n = < LONG >
		{
		  System.out.println(n.image);
		  return n.image;
		}
		|n = < SHORT >
		{
		  System.out.println(n.image);
		  return n.image;
		}
	)
	
}

String types():
{
  String type;
  Token n;
}{
  n =  < IDENTIFIER >  {    return n.image;  }  |type = primitive_types()  {
    return type;  }}
ASTExpressionAssignment create_variable():{
  String type;
  String id_name;
  Token id;
  Token var_id = new Token();
  ASTExpressionAssignment result;
  ASTExpressionUnitIdentifier var;
  ASTExpressionUnitValue v = new ASTExpressionUnitValue();
  ASTExpressionUnitIdentifier dest_var = new ASTExpressionUnitIdentifier();}
{
  < CREATE >type = types()< TYPE ><VARIABLE >id=< IDENTIFIER >(< VALUE >v = value()|< FUNCTION >|< VARIABLE >var_id=< IDENTIFIER >)< TERMINATOR >	{
	  var = new ASTExpressionUnitIdentifier(id.image,type,true);
	  if(v.getValue() == null)	  {		dest_var = new ASTExpressionUnitIdentifier(var_id.image,type);
		result = new ASTExpressionAssignment(var,dest_var);
	  }else	  {	    result = new ASTExpressionAssignment(var,v);
	  }
	  
	  System.out.println(result.print());
	  return result;	}
}
void fragment():
{
  Token var = new Token();
  Token check = new Token();
  ASTExpressionUnitValue v = new ASTExpressionUnitValue();
}
{
  (< VALUE >v = value())|(< VARIABLE >var = < IDENTIFIER >)|(< FUNCTION >)|(check = < LPAREN > expression()< RPAREN >)}

void term():
{}
{	fragment()(< INFIX_OPERATOR >fragment())+
}

void infix_expression():{}
{	term()
}
void prefix_expression():{}
{	(< TEXT_BIT_NOT ><VALUE >value())|(< PREFIX_OPERATOR ><VARIABLE ><IDENTIFIER >)
}

void postfix_expression():{}
{
  (< VARIABLE ><IDENTIFIER >)< POSTFIX_OPERATOR >}

void expression():
{}
{
  (LOOKAHEAD(2)prefix_expression()|LOOKAHEAD(2)infix_expression()|LOOKAHEAD(2)postfix_expression())
}

void assignment():
{}
{	< ASSIGNMENT ><VARIABLE ><IDENTIFIER ><WITH>expression()< TERMINATOR >
}

void if_statement():
{}
{
  < IF > <CONDITION >expression()< IF_BRANCH_START >(statement())+<IF_BRANCH_END >}
void statement():
{}
{
  < ASSIGNMENT >}
